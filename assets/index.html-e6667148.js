import{_ as t,n as r,p as l,q as c,s as e,R as n,t as s,Z as a}from"./framework-fdd38eac.js";const i="/assets/demo1-4f798e20.png",p="/assets/demo2-e981925f.png",d="/assets/demo3-e23f9a0b.png",h="/assets/demo4-754b13c2.png",m="/assets/demo5-7e29fa5f.png",u="/assets/demo6-2ae9e98e.png",_="/assets/demo7-ec5d9612.png",k="/assets/demo8-017688a8.png",x={},w=e("h1",{id:"workspace工作空间",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#workspace工作空间","aria-hidden":"true"},"#"),n(" workspace工作空间")],-1),g=e("p",null,"Yarn Workspaces（工作空间/工作区，本文使用工作空间这一名称），用于在代码仓库的根目录下管理多个project的依赖。",-1),f=e("div",{class:"custom-container info"},[e("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[e("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[e("circle",{cx:"12",cy:"12",r:"9"}),e("path",{d:"M12 8h.01"}),e("path",{d:"M11 12h1v4h1"})])]),e("p",{class:"custom-container-title"},"INFO"),e("p",null,"背景：文档中需要对组件进行演示，一般让演示的示例 和 演示的代码共用一套，避免示例代码改动时，演示的代码还需要粘贴一遍，难以维护。")],-1),v=a('<p><img src="'+i+'" alt="1563094729353"><img src="'+p+'" alt="1563094729353"> 我们可以通过插件，把示例和对应的演示代码都共用一个文件，这样只需改一个文件即可。 <img src="'+d+'" alt="1563094729353"></p><h2 id="公用文件引出的问题" tabindex="-1"><a class="header-anchor" href="#公用文件引出的问题" aria-hidden="true">#</a> 公用文件引出的问题</h2>',2),b=e("div",{class:"custom-container info"},[e("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[e("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[e("circle",{cx:"12",cy:"12",r:"9"}),e("path",{d:"M12 8h.01"}),e("path",{d:"M11 12h1v4h1"})])]),e("p",{class:"custom-container-title"},"INFO"),e("ul",null,[e("li",null,[n("示例的引入是"),e("code",null,"import { comdify } from '../../../packages/tools'"),n("要相对路径才可以引入到对应库的代码。")]),e("li",null,[n("虽然这样可以引入到库代码，但是使用时实际上是 "),e("code",null,"import { comdify } from '@xxx/tools'"),n("这样去引入代码， 但是也不能把包发布之后再把包install之后再做调试，因为包没有经过测试就发布了。 另一种方法就是"),e("code",null,"npm link"),n("把包注册到全局，通过"),e("code",null,"npm link @xxx/toosl"),n("去调试，目前只有两个包当然可以，但是如果调试的包再多，就变的难以调试及维护。 这时候就需要使用workspace工作空间。")])])],-1),y=e("p",null,[e("img",{src:h,alt:"1563094729353"})],-1),q=e("h2",{id:"pnpm",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#pnpm","aria-hidden":"true"},"#"),n(" pnpm")],-1),j=e("li",null,"比其他包管理器快 2 倍；",-1),M=e("li",null,"依赖只安装一次，其他项目的依赖会通过软链接指向上级依赖（不占用磁盘空间）；",-1),N={href:"https://juejin.cn/post/7127295203177676837",target:"_blank",rel:"noopener noreferrer"},B={href:"https://pnpm.io/zh/workspaces",target:"_blank",rel:"noopener noreferrer"},I=e("h2",{id:"yarn",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#yarn","aria-hidden":"true"},"#"),n(" Yarn")],-1),W=e("ul",null,[e("li",null,[n("Yarn Workspaces（工作空间/工作区，本文使用工作空间这一名称）是Yarn提供的Monorepo依赖管理机制，从Yarn 1.0开始默认支持。 "),e("ul",null,[e("li",null,"最常见的 monorepo 解决方案是 Lerna 和 yarn 的 workspaces 特性，基于lerna和yarn workspace的monorepo工作流。由于yarn和lerna在功能上有较多的重叠,我们采用yarn官方推荐的做法,用yarn来处理依赖问题，用lerna来处理发布问题。")])])],-1),Y=e("h2",{id:"工具的选择",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#工具的选择","aria-hidden":"true"},"#"),n(" 工具的选择")],-1),C=e("ul",null,[e("li",null,"pnpm和yarn都具有工作区Workspaces的功能，目前pnpm在磁盘占用空间、下载速度、幽灵依赖处理的更好，发展迅速，选择pnpm更优。"),e("li",null,"lerna是版本管理工具，对于版本的工作流处理方面更好，对于有版本依赖关系需要处理则需要用lerna。")],-1),V=e("div",{class:"custom-container info"},[e("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[e("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[e("circle",{cx:"12",cy:"12",r:"9"}),e("path",{d:"M12 8h.01"}),e("path",{d:"M11 12h1v4h1"})])]),e("p",{class:"custom-container-title"},"INFO"),e("p",null,"对于此处的两个库之间没有依赖关系，暂时并不选择使用lerna，只需要具有workspace功能的pnpm。")],-1),E=a('<h2 id="workspace-协议-workspace" tabindex="-1"><a class="header-anchor" href="#workspace-协议-workspace" aria-hidden="true">#</a> Workspace 协议 (workspace:)</h2><p>使用此协议时，pnpm 将拒绝解析除本地 workspace 包含的 package 之外的任何内容。 例如： 设置为 <code>&quot;@xxx/tools&quot;: &quot;workspace:*&quot;</code> 时，pnpm会从<code>pnpm-workspace.yaml</code>文件定义的工作空间去找<code>@xxx/tools</code> 这个包，如果存在那么将链接指向该包。 如果包不存在，安装将会失败，因为 <code>&quot;@xxx/tools&quot;</code> 不存在于此 workspace 中。</p><h2 id="pnpm的配置" tabindex="-1"><a class="header-anchor" href="#pnpm的配置" aria-hidden="true">#</a> pnpm的配置</h2><p>对于workspace功能的配置 <img src="'+m+`" alt="1563094729353"></p><blockquote><p>pnpm-workspace.yaml</p></blockquote><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">packages</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> docs
  <span class="token punctuation">-</span> packages/*
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>package.json</p></blockquote><p><img src="`+u+'" alt="1563094729353"></p><p>会把packages文件夹下的包中的name包名都注册到整个工作区中。 <img src="'+_+'" alt="1563094729353"> 最后通过引用<code>@xxx/tools</code>可以链接到工作区中的tools库中，演示代码和demo代码的改动最终完成。 <img src="'+k+'" alt="1563094729353"></p>',9);function F(L,O){const o=r("ExternalLinkIcon");return l(),c("div",null,[w,g,f,v,b,y,q,e("ul",null,[e("li",null,[n("performant（高性能的）npm。 "),e("ul",null,[j,M,e("li",null,[n("解决了yarn、npm"),e("a",N,[n("幽灵依赖"),s(o)]),n("的问题。")])])]),e("li",null,[n("pnpm 内置支持"),e("a",B,[n("工作空间"),s(o)]),n("（Workspaces）。")])]),I,W,Y,C,V,E])}const R=t(x,[["render",F],["__file","index.html.vue"]]);export{R as default};
