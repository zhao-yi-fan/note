import{_ as e,p as s,q as a,Z as t}from"./framework-fdd38eac.js";const o="/assets/1558170327431-98d9268f.png",p="/assets/1558170381692-07ba77d0.png",n="/assets/1558170448850-a4e62110.png",i="/assets/1558170474713-11887e58.png",c="/assets/1558170513875-4ede286c.png",d="/assets/1558171654991-ed8d6947.png",l="/assets/1558171678022-ceddc619.png",r="/assets/1558192146356-4871369a.png",h="/assets/1558197307392-d512c63a.png",u="/assets/1558235665452-f8aff2d7.png",m="/assets/1558235832092-0e91c295.png",g="/assets/1558172181602-97fe8bd7.png",b="/assets/1558173518163-0596a285.png",v="/assets/1558255601190-a727bd1d.png",_="/assets/1558192206340-4fb54057.png",f="/assets/1558204790539-677eb012.png",k="/assets/1558174773145-cbf4f9ed.png",x="/assets/1558176161028-fd1a9d8f.png",q="/assets/1558176265153-be80cffb.png",P="/assets/1558176649136-d4874932.png",w="/assets/1558176938496-53fc1334.png",I="/assets/1558177066220-c03bb743.png",S="/assets/1558177094693-7ce6f103.png",D="/assets/1558190994940-a23d9c10.png",H="/assets/1558236035825-36d19992.png",N="/assets/1558191157373-6b3e3019.png",A="/assets/1558199597750-507c835f.png",V="/assets/1558204659255-4ebda14a.png",L="/assets/1558204153521-3c599780.png",R="/assets/1558204346157-3729b60f.png",y="/assets/1558317204841-9f28242b.png",M="/assets/1558255953379-f67fe5c0.png",T="/assets/1558256522373-32d9fb64.png",E={},U=t('<h1 id="服务端开发基础" tabindex="-1"><a class="header-anchor" href="#服务端开发基础" aria-hidden="true">#</a> 服务端开发基础</h1><h2 id="搭建web服务器" tabindex="-1"><a class="header-anchor" href="#搭建web服务器" aria-hidden="true">#</a> 搭建Web服务器</h2><h3 id="web服务器软件" tabindex="-1"><a class="header-anchor" href="#web服务器软件" aria-hidden="true">#</a> Web服务器软件</h3><ul><li><p>Nginx -&gt; 反向代理</p></li><li><p>Apache -&gt; PHP</p></li><li><p>IIS -&gt; ASP.NET</p></li><li><p>Tomcat -&gt; Java</p></li></ul><p>Apache并不是只能跑PHP,也可以跑java, .net</p><h3 id="安装web服务器软件" tabindex="-1"><a class="header-anchor" href="#安装web服务器软件" aria-hidden="true">#</a> 安装Web服务器软件</h3><p>常用的Web服务器软件: Apache HTTP Server</p><ul><li>服务器</li></ul><p>服务器就是指安装特定的软件的公共计算机, 用于专门用于提供特定的服务.</p><p>GUI</p><p>图形用户界面 Graphical User Interface</p><h2 id="ip地址与防火墙介绍" tabindex="-1"><a class="header-anchor" href="#ip地址与防火墙介绍" aria-hidden="true">#</a> IP地址与防火墙介绍</h2><h3 id="ip地址的单网络与多网络情况" tabindex="-1"><a class="header-anchor" href="#ip地址的单网络与多网络情况" aria-hidden="true">#</a> IP地址的单网络与多网络情况</h3><p>如果电脑没有连接任何网络的情况下, 电脑会有本地回环地址127.0.0.1</p><ul><li>单个网络情况</li></ul><p><img src="'+o+'" alt="1558170327431"></p><ul><li>多个网络情况</li></ul><p>谁发出的热点谁就是网关</p><p>当电脑的网线和wifi同时连接网络并且分别是两个网关, 那么想要拿其他电脑或手机访问该电脑服务器的话, 就需要判断连接的是哪个网关, 每个网关对应的ip地址不一样.</p><p>比如下图,设备C想访问A服务器的内容, 访问的IP地址为192.168.1.100</p><p>设备D想访问A服务器的内容, 访问的IP地址为172.16.1.123</p><p><img src="'+p+'" alt="1558170381692"></p><p>电脑同时连接一个路由器的wifi和网线</p><p><img src="'+n+'" alt="1558170448850"></p><p>电脑只连接wifi的情况</p><p><img src="'+i+'" alt="1558170474713"></p><p>电脑网线连接路由器,wifi连接的是手机发出的热点</p><p><img src="'+c+'" alt="1558170513875"></p><h3 id="防火墙" tabindex="-1"><a class="header-anchor" href="#防火墙" aria-hidden="true">#</a> 防火墙</h3><p><img src="'+d+'" alt="1558171654991"></p><p>右键禁用规则别人就不可以访问本机的Apache服务器了</p><p><img src="'+l+'" alt="1558171678022"></p><h2 id="域名" tabindex="-1"><a class="header-anchor" href="#域名" aria-hidden="true">#</a> 域名</h2><p>修改Apache本地主机的访问名字</p><p><img src="'+r+'" alt="1558192146356"></p><h2 id="dns" tabindex="-1"><a class="header-anchor" href="#dns" aria-hidden="true">#</a> DNS</h2><p>通过宽带运营商提供的服务器解析一个域名背后对应的 IP，这个过程叫做 DNS 寻址，帮你完成 DNS 寻址过程的服务器叫做 DNS 服务器。</p><h3 id="hosts文件" tabindex="-1"><a class="header-anchor" href="#hosts文件" aria-hidden="true">#</a> hosts文件</h3><p>操作系统在发起DNS服务器的查询请求之前, 会优先检查本机的hosts文件. 如果这个文件中包含了对当前需要解析的域名的配置, 则不再发起对DNS服务器的请求,直接使用hosts文件中的配置.</p><p><img src="'+h+'" alt="1558197307392"></p><p>如果是浏览器发起DNS服务器请求时，会先找浏览器DNS缓存-&gt;操作系统DNS缓存-&gt;hosts文件-&gt;DNS服务器</p><h3 id="dns缓存清理" tabindex="-1"><a class="header-anchor" href="#dns缓存清理" aria-hidden="true">#</a> DNS缓存清理</h3><ul><li>chrome清理DNS缓存：<code>&lt;chrome://net-internals/#dns&gt;</code></li></ul><p><img src="'+u+'" alt="1558235665452"></p><ul><li>清理windows电脑DNS缓存：命令行窗口<code>config \\flushdns</code></li></ul><p><img src="'+m+'" alt="1558235832092"></p><p><strong>hosts文件所在路径:</strong></p><ul><li>Windows: <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code></li><li>macOS: <code>/etc/hosts</code></li></ul><p><strong>注意:</strong></p><ul><li><p>本机的hosts文件配置只能影响到本机的DNS寻址</p></li><li><p>只有以管理员权限运行得编辑器才有权利修改hosts文件</p></li><li><p>以管理员运行得编辑器此时是管理员权限，不能拖拽编辑普通的文件。用普通用户权限打开编辑器，才能拖拽编辑普通的文件。</p></li></ul><p><strong>生活例子:</strong></p><blockquote><p>每个宿舍都有一个路由器, 每个宿舍的路由器可能会集中到一个楼的总交换机, 每个楼和每个楼的交换机又会汇总到移动,联通等总的交换机上.总的交换机是有一个公网IP, 虽然自己的电脑是从公网IP架设出来的,但是访问公网IP是不会访问到自己的电脑上的.需要制定自己的IP.</p><p>移动,联通等总网关默认把80端口屏蔽了, 因为怕用户会通过总网关IP做服务器, 那样是找不到具体的人的.</p><p>阿里云服务器, 腾讯云服务器, 这些云服务器都是实名制的.</p></blockquote><p><img src="'+g+'" alt="1558172181602"></p><h2 id="端口" tabindex="-1"><a class="header-anchor" href="#端口" aria-hidden="true">#</a> 端口</h2><p>每台计算机只有65536个端口(0-65535)</p><blockquote><p><code>netstat -an</code>命令行监听本机端口的使用情况</p><p><code>http</code>默认端口80</p><p><code>https</code>默认端口443</p></blockquote><h2 id="url" tabindex="-1"><a class="header-anchor" href="#url" aria-hidden="true">#</a> URL</h2><p>Uniform Resource Locator 统一资源定位符</p><p><img src="'+b+'" alt="1558173518163"></p><p>例如：https://zce.me:80/schools/students?id=18&amp;name=zce#photo</p><h2 id="请求响应流程" tabindex="-1"><a class="header-anchor" href="#请求响应流程" aria-hidden="true">#</a> 请求响应流程</h2><p><img src="'+v+'" alt="1558255601190"></p><ol><li>用户打开浏览器</li><li>地址栏输入我们需要访问的网站网址(URL)</li><li>浏览器通过DNS服务器获取即将访问的网站IP地址</li><li>浏览器发起一个对这个IP的请求</li><li>服务端接收到这个请求，进行响应的处理</li><li>服务端将处理完的结果返回给客户端浏览器</li><li>浏览器将服务端返回的结果呈现到界面上</li></ol><h2 id="配置apache" tabindex="-1"><a class="header-anchor" href="#配置apache" aria-hidden="true">#</a> 配置Apache</h2><blockquote><p>配置文档：http://httpd.apache.org/docs/current/ 配置文件中行首的 # 指的是注释 注意：以下所记录的行号仅供参考，不同版本的配置文件可能不尽相同。</p></blockquote><h3 id="监听端口" tabindex="-1"><a class="header-anchor" href="#监听端口" aria-hidden="true">#</a> 监听端口</h3><p>监听端口可以随意修改为任意一个未被其他程序监听的端口，可以通过设置配置文件<code>httpd.conf</code>中的<code>Listen</code>指令后面的数字修改。</p><p><img src="'+_+'" alt="1558192206340"></p><h3 id="网站根目录" tabindex="-1"><a class="header-anchor" href="#网站根目录" aria-hidden="true">#</a> 网站根目录</h3><blockquote><p>网站根目录: 就是存放我们网站文件的最顶层目录，通常 URL 中域名后面的第一个斜线对应（映射）的就是网站根目录。 默认文档: 指的是我们在访问某一个目录时（没有指定具体的文件），默认访问的文件叫做默认文档 注：动态网站情况会比较特殊，需要单独考虑，不一定是这个规则。</p></blockquote><p>默认 Apache 的网站根目录是安装目录中的<code>htdocs</code>文件夹，为了方便对网站文件的管理，一般我们会将其设置在一个自定义目录中（如果你不介意其实不修改也无所谓）。</p><p>如果需要设置网站根目录，可以通过修改Apache配置文件<code>httpd.conf</code>中的网站根目录选项切换。</p><p><img src="'+f+'" alt="1558204790539"></p><p><img src="'+k+'" alt="1558174773145"></p><blockquote><p>默认不允许在磁盘根目录设置网站根目录 因为会访问到所有文件</p></blockquote><p><img src="'+x+'" alt="1558176161028"></p><blockquote><p>可以在该地方进一步设置某个根目录可以访问</p></blockquote><p><img src="'+q+'" alt="1558176265153"></p><h3 id="默认文档" tabindex="-1"><a class="header-anchor" href="#默认文档" aria-hidden="true">#</a> 默认文档</h3><blockquote><p>当客户端访问的是一个目录而不是具体文件时，服务端默认返回这个目录下的某个文档（文件），这个文档就称之为默认文档, 一般是index.html</p></blockquote><p>配置文件<code>httpd.conf</code>的 280 行的<code>DirectoryIndex</code>，默认文档可以配置多个（有前到后依次去找，找到为止，如果没找到任何一个则启用目录浏览）</p><p><img src="'+P+'" alt="1558176649136"></p><blockquote><p>如果没有默认文档, 但是也不想让看到文档目录,可以把下图的<code>Indexes</code>删除, 就不会显示目录文档</p></blockquote><p><img src="'+w+'" alt="1558176938496"></p><blockquote><p>目录文档</p></blockquote><p><img src="'+I+'" alt="1558177066220"></p><blockquote><p>关闭目录文档 <code>Indexes</code>删除</p></blockquote><p><img src="'+S+'" alt="1558177094693"></p><h3 id="虚拟主机" tabindex="-1"><a class="header-anchor" href="#虚拟主机" aria-hidden="true">#</a> 虚拟主机</h3><h4 id="配置虚拟主机" tabindex="-1"><a class="header-anchor" href="#配置虚拟主机" aria-hidden="true">#</a> 配置虚拟主机</h4><p>​ 如果一台机器上只有一个网站的话，没有任何问题，但是如果想要在一台机器上部署多个站点，就必须通过配置虚拟主机的方式解决。</p><p><img src="'+D+'" alt="1558190994940"></p><p>​ 对于Apache而言，主机有两类：不能同时使用，如果要定义虚拟主机，那么必须为现存的主机也创建一个<code>&lt;VirtualHost&gt;</code></p><ol><li>中心主机（MainHost）未配置虚拟主机时</li><li>虚拟主机（Vhost）如果配置了中心主机，同时也想配置虚拟主机，那么把中心主机也配置虚拟主机</li></ol><ul><li><p>取消中心主机</p><ul><li>如果想在现有的web服务器上增加虚拟主机，你必须也为现存的主机建造一个<code>&lt;VirtualHost&gt;</code>定义块。这个虚拟主机中<code>ServerName</code>和<code>DocumentRoot</code>所包含的内容应该与全局的<code>ServerName</code>和<code>DocumentRoot</code>保持一致。还要把这个虚拟主机放在配置文件的最前面，来让它扮演默认主机的角色。</li><li>如果不想使用中心主机，直接在<code>httpd.conf</code>配置文件中注释掉中心主机的DocumentRoot即可。</li></ul><p><img src="'+H+`" alt="1558236035825"></p></li><li><p>虚拟主机的配置文件</p><p>​ 可以直接在主配置文件<code>httpd.conf</code>中直接配置,但是这样不利于维护,建议在<code>apache\\conf\\extra\\httpd-vhosts.conf</code>建立配置文件。前提是在<code>httpd.conf</code>中配置了<code>Include conf/extra/httpd-vhosts.conf</code></p><p>​ 我们通过<code>&lt;VirtualHost&gt;</code>指令来定义虚拟主机，<code>ServerName</code>和<code>DocumentRoot</code>是一个虚拟主机最基本的两个配置，其他可以在中心主机配置的指令，基本都可以应用于虚拟主机。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&lt;</span>VirtualHost IP:PORT<span class="token operator">&gt;</span>
    ServerName
    DocumentRoot <span class="token string">&quot;/path/to/&quot;</span>
<span class="token operator">&lt;</span>/VirutalHost<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="基于域名的虚拟主机" tabindex="-1"><a class="header-anchor" href="#基于域名的虚拟主机" aria-hidden="true">#</a> 基于域名的虚拟主机</h4><blockquote><p>​ 由于后期对虚拟主机的配置操作非常常见，所以我们一般将虚拟主机的配置单独放到一个配置文件中，然后在主配置文件中引入，避免破坏主配置文件中的其他配置。</p><p><code>Include conf/extra/httpd-vhosts.conf</code> 配置的作用就将另外一个配置文件引入（使其生效）</p></blockquote><p>​ 具体的操作方式就是在主配置文件 httpd.conf 的 505 行取消注释：</p><p><img src="`+N+'" alt="1558191157373"></p><p>​ 然后找到 Apache 的虚拟主机配置文件，添加一个如下的虚拟主机配置节点，然后重新启动 Apache。</p><blockquote><p>文件路径<code>apache\\conf\\extra\\httpd-vhosts.conf</code></p><p>这个文件中有两个默认的示例配置，可以注释掉使用</p></blockquote><p><img src="'+A+'" alt="1558199597750"> 如果真的要使用<code>www.aaa.com</code>这个域名的话，就只能通过修改 hosts 文件达到目的，原因很简单：这个域名不是我们自己的，我们没有办法修改这个域名在公网上的 DNS。 <strong>注意：</strong></p><ul><li><p>如果使用了虚拟主机，则默认必须全部使用虚拟主机，即之前的默认网站也必须通过虚拟主机方式配置，否则访问不到。参考：http://skypegnu1.blog.51cto.com/8991766/1532454</p></li><li><p>如果虚拟主机的端口使用的不是 80 ，则需要在主配置文件中添加一个对这个端口的监听：</p><p><img src="'+V+'" alt="1558204659255"></p></li></ul><p>如果出现了<code>Forbidden</code></p><p><img src="'+L+'" alt="1558204153521"></p><blockquote><p>需要手动设置具体的目录，在路径<code>apache\\conf\\extra</code>的<code>httpd-vhosts.conf</code>文件设置：添加一个Directory节点解决</p></blockquote><p><img src="'+R+`" alt="1558204346157"></p><p>​ 当一个请求到达的时候，服务器会先检查它是否使用了一个能和<code>NameVirtualHost</code>相匹配的IP地址。如果能够匹配，它就会查找每个与这个IP地址相对应的<code>&lt;VirtualHost&gt;</code>段，查看是否有与请求主机名相同的<code>ServerName</code>或者<code>ServerAlias</code>。如果找到了，就会使用这个虚拟主机。否则，将使用符合这个IP地址的第一个列出来的虚拟主机。</p><p><strong>注意</strong></p><p><code>NameVirtualHost *:80</code> apache2.2需要此指令启动基于域名的虚拟主机，apache2.4不需要</p><p>​ 第一个列出的虚拟主机充当了<code>默认虚拟主机</code>的角色。当一个IP地址与<code>NnmeVirtualHost</code>指令中的配置相符的时候，<code>主服务器</code>中的<code>DocumentRoot</code>将<strong>永远不会</strong>被用到。所以，如果想创建一段特殊的配置用于处理不对应任何一个虚拟主机的话，需要自己写一个虚拟主机，放到配置文件的最前面即可。</p><blockquote><p>把一个父文件允许被访问，下面的每个子文件都是一个虚拟主机，就不用每个虚拟主机都加文件被访问的配置了</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># 配置这个目录允许被访问，否则出现 Forbidden
&lt;Directory &quot;D:/www&quot;&gt;
    Options Indexes FollowSymLinks Includes ExecCGI
    AllowOverride All
    Require all granted
&lt;/Directory&gt;
&lt;VirtualHost *:8081&gt;
    # 虚拟主机根目录
    DocumentRoot &quot;D:/www/aaa&quot;
    # 虚拟主机域名
    ServerName www.aaa.com
    # 虚拟主机错误日志
    ErrorLog &quot;logs/www.aaa.com-error.log&quot;
    # 虚拟主机访问日志
    CustomLog &quot;logs/www.aaa.com.log&quot; common
&lt;/VirtualHost&gt;

&lt;VirtualHost *:8081&gt;
    # 虚拟主机根目录
    DocumentRoot &quot;D:/www/asd&quot;
    # 虚拟主机域名
    ServerName asd.com
    ServerAlias bbbb.com
    # 虚拟主机错误日志
    ErrorLog &quot;logs/www.asd.com-error.log&quot;
    # 虚拟主机访问日志
    CustomLog &quot;logs/www.asd.com.log&quot; common
&lt;/VirtualHost&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+y+'" alt="1558317204841"></p><h2 id="静态网站与动态网站" tabindex="-1"><a class="header-anchor" href="#静态网站与动态网站" aria-hidden="true">#</a> 静态网站与动态网站</h2><p>​ 至此，我们已经可以把这些静态页面放到服务器上了，客户端也可以通过域名请求这个网站，但是对于我们来说，Apache 能够完成的事情过于简单，无外乎就是找到你请求对应的文件 → 读取文件 → 将文件内容响应给客户端浏览器（<strong>文件原封不动的给你</strong>）。<strong>无法满足让网页内容动起来（随着数据动态变化）的需求。</strong> ​ 于是乎，就有人提出了<strong>服务端动态网页的概念</strong>，这种实现这种概念的技术有很多种：JSP、ASP.NET、PHP、Node等等。 ​ 这些技术的原理就是：不再将 HTML 固定写死，每次用户请求时，动态执行一段代码，临时生成一个用户想要的HTML 页面。</p><p><img src="'+M+`" alt="1558255953379"> <strong>动态网站指的也就是每次请求时服务端动态生成 HTML 返回给用户的这种网站。</strong></p><h3 id="配置-php-支持" tabindex="-1"><a class="header-anchor" href="#配置-php-支持" aria-hidden="true">#</a> 配置 PHP 支持</h3><blockquote><p>PHP 文件的扩展名就是 .php</p></blockquote><p>​ 我们可以尝试在刚刚配置的网站中添加一个扩展名为 php 的文件，然后到浏览器中访问它。</p><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!‐‐</span> <span class="token attr-name">demo.php</span> <span class="token attr-name">‐‐</span><span class="token punctuation">&gt;</span></span>
<span class="token php language-php"><span class="token delimiter important">&lt;?php</span> <span class="token keyword">echo</span> <span class="token string single-quoted-string">&#39;Hello PHP&#39;</span><span class="token punctuation">;</span> <span class="token delimiter important">?&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 结果出乎意料，并没有显示我们想要的 Hello PHP ，而是将我们的代码原封不动的返回给浏览器了。</p><p>​ 原因很简单：Apache 只能处理静态文件请求，对于后缀名为 <code>.php</code> 这种动态文件，它无法执行，所以就当成是一个静态文件直接返回了。</p><p><strong>解决方法：</strong></p><ul><li><p>在服务器上安装 PHP</p><ul><li>解压 php 到纯英文路径目录中</li></ul></li><li><p>在 Apache 中添加支持 PHP 的配置</p><ul><li><p>在 Apache 添加 PHP 处理模块</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># php support</span>
<span class="token comment"># 这个模块不是根据后缀判断是否该PHP工作，根据 MiME Type 是不是 application/x-httpd-php来决定PHP工作</span>
LoadModule php7_module <span class="token punctuation">[</span>php7apache2_4.dll的路径<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>在<code>&lt;IfModule mime_module&gt;</code>节点中添加 .php 扩展名解析支持</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># parse .php files
AddType application/x-httpd-php .php
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>默认文档配置节点 <code>&lt;IfModule dir_module&gt;</code> 中添加<code>index.php</code></p><blockquote><p>默认文档指的是在访问一个目录而不是具体文件名时，默认执行的文件名</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;IfModule dir_module&gt;
	DirectoryIndex index.html index.php
&lt;/IfModule&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>重启Apache</p></li></ul><h3 id="apache与php" tabindex="-1"><a class="header-anchor" href="#apache与php" aria-hidden="true">#</a> Apache与PHP</h3><blockquote><p>php与apache是apache服务器找到php的配置，可以解析php文件</p></blockquote><blockquote><p>php也可以和tomcat服务器搭配</p></blockquote><blockquote><p>Apache是根据文件的扩展名找到文件的类型，然后挨个查看每一个模块能够处理这个类型的文件，如果这些模块都不能处理，那么Apache就自己处理（按照静态文件的方式处理）</p></blockquote><p><img src="`+T+'" alt="1558256522373"></p>',130),W=[U];function C(O,F){return s(),a("div",null,W)}const z=e(E,[["render",C],["__file","index.html.vue"]]);export{z as default};
