import{_ as o,p as t,q as e,Z as p,s,R as n}from"./framework-fdd38eac.js";const r="/assets/文本存在mysql中-d2c2dac6.png",a="/assets/mysql和redis-1541afa4.png",c="/assets/存储层和缓存层-a02351d8.png",d="/assets/CDN和OSS-ffc103ce.png",g="/assets/1667103075060-96803664.png",i="/assets/CDN的查询流程-f6522770.png",l="/assets/640-268c36a8.png",u="/assets/CDN专用的DNS解析服务器会返回就近的CDN节点IP-51856358.png",m="/assets/1667101182393-bfc92ebb.png",b="/assets/1668605964836-69a7c89e.png",N="/assets/有缓存直接返回和没缓存回源的区别-1507471e.png",h="/assets/查看response-header-8d50e9da.png",D="/assets/回源的情况-8aa687cb.png",C="/assets/1667095186020-c5de35b4.png",v="/assets/更新直接访问源站-6dae5d88.png",_="/assets/更新走了CDN还回源-7e703848.png",k="/assets/cdn刷新预热-63c5dbe4.png",q="/assets/1667344813600-d490b4da.png",x="/assets/1668612494972-83ced844.png",S={},I=p('<h1 id="cdn" tabindex="-1"><a class="header-anchor" href="#cdn" aria-hidden="true">#</a> CDN</h1><h2 id="cdn是什么" tabindex="-1"><a class="header-anchor" href="#cdn是什么" aria-hidden="true">#</a> CDN是什么</h2><p>对于<code>数字和文本类型</code>的数据，比方说名字和电话号码相关的信息。我们需要有个地方存起来。</p><p>我们通常会用<code>mysql数据库</code>去存。</p><p><img src="'+r+'" alt="文本存在mysql中"></p><p>当我们需要重新将这一数据取出的时候，就需要去读mysql数据库。</p><p>但因为mysql的数据是存在磁盘上的，单台实例，读性能到差不多5kqps就已经很不错了。</p><p>看起来还凑合，但对于稍微大一点的系统，就稍微有点捉急了。</p><p>为了提升点性能，我们在mysql之前再加一层内存做缓存层，比如常说的redis，读数据优先到内存里读，读不到才到mysql里读，大大减少了读mysql的次数。有了这套组合拳，读性能轻松上万qps。</p><p><img src="'+a+'" alt="mysql和redis"></p><p>好了，到这里，我们说的都是我们平时比较容易接触的开发场景。</p><p>但如果现在我要处理的，<code>不再是上面提到的文本类数据，而是图片数据</code>。</p><p>比如，每次刷某音听到有人翻唱蔡健雅的《letting go》的时候，我都忍不住想发同一张在评论区 并配文&quot;还是忘不了&quot;。</p><p>那么问题来了。</p><p><strong>这张图片数据应该存在哪？又该从哪里读？</strong></p><p>我们回过头去看mysql和redis的场景，无非就是<strong>存储层加缓存层</strong>。</p><p><img src="'+c+'" alt="存储层和缓存层"> 对于图片这样的<strong>文件对象</strong>，<strong>存储层</strong>不太可能再用mysql，应该改用专业的<strong>对象存储</strong>，比如亚马逊的<code>S3</code>（Amazon Simple Storage Service，注意后面是三个S开头的单词，所以叫s3），或者阿里云的<strong>oss</strong>（Object Storage Service）。下面的内容，我们就用比较常见的oss去做解释。</p><p>而<strong>缓存层</strong>，也不能继续用redis了，需要改成使用<code>CDN</code>（<strong>C</strong>ontent <strong>D</strong>elivery <strong>N</strong>etwork，内容分发网络）。</p><p><strong>可以将CDN简单理解为对象存储对应的缓存层。</strong></p><p><img src="'+d+'" alt="CDN和OSS"> 现在就可以回答上面的提问，对用户来说，这张图片数据存在了<strong>对象存储</strong>那，当有需要的时候，会从<strong>CDN</strong>那被读出来。</p><h2 id="cdn的工作原理" tabindex="-1"><a class="header-anchor" href="#cdn的工作原理" aria-hidden="true">#</a> CDN的工作原理</h2><p>有了CDN和对象存储之后，现在我们来看下他们之间是怎么工作的。</p><p>我们平时看到的图片，可以右键复制查看它的URL。</p><p><img src="'+g+`" alt="1667103075060"></p><p>会发现图片的URL长这样。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>https://cdn.xiaobaidebug.top/1667106197000.png
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中前面的<code>cdn.xiaobaidebug.top</code>就是<code>CDN</code>的域名，后面的<code>1667106197000.png</code>是图片的路径名。</p><p>当我们在浏览器输入这个URL就会发起HTTP GET请求，然后经历以下过程。</p><p><img src="`+i+'" alt="CDN的查询流程"><strong>第一阶段:</strong> 你的电脑会先通过DNS协议获得<code>cdn.xiaobaidebug.top</code>这个域名对应的IP。</p><p>• step1和step2：先查看浏览器缓存，再看操作系统里的<code>/etc/hosts</code>缓存，如果都没有，就会去询问最近的DNS服务器（比如你房间里的家用路由器）。最近的DNS服务器上有没有对应的缓存，如果有则返回。</p><p>• step3：如果最近的DNS服务器上没有对应的缓存，就会去查询根域，一级域，二级域，三级域服务器。</p><p>• step4：然后，最近的DNS服务器会得到这个<code>cdn.xiaobaidebug.top</code>域名的别名（CNAME），比如<code>cdn.xiaobaidebug.top.w.kunlunaq.com</code>。</p><p>• <code>kunlunaq.com</code>是阿里CDN专用的DNS调度系统。</p><p>• step5到step7：此时<strong>最近的DNS服务器</strong>会去请求这个<code>kunlunaq.com</code>，然后返回一个<strong>离你最近的IP地址</strong>返回给你。</p><p><strong>第二阶段:</strong> 对应上图里的step8。浏览器拿着这个IP去访问<strong>cdn节点</strong>，然后，cdn节点返回数据。</p><p>上面第一阶段流程里，提到了很多新的名词，比如<code>CNAME，根域，一级域</code>啥的，它们在之前写的 「DNS中有哪些值得学习的优秀设计」有很详细的描述，如果不了解的话可以去看下。</p><p>我们知道<strong>DNS的目的就是通过域名去获得IP地址。</strong></p><p>但这只是它的众多功能之一。</p><p>DNS消息有很多种类型，其中<strong>A类型</strong>，就是用域名去查域名对应的IP地址。而<strong>CNAME类型</strong>，则是用域名去查这个域名的<strong>别名</strong>。</p><p><img src="'+l+`" alt="640"> 对于<strong>普通域名</strong>，DNS解析后一般就能直接得到域名对应的IP 地址（又叫<code>A类型记录</code>，A指Address）。</p><p>比如下面，我用<code>dig</code>命令发出DNS请求并打印过程数据。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">dig</span> +trace xiaobaidebug.top
<span class="token punctuation">;</span><span class="token punctuation">;</span> ANSWER SECTION:
xiaobaidebug.top. <span class="token number">600</span> IN A <span class="token number">47.102</span>.221.141
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到<code>xiaobaidebug.top</code>直接解析得到对应的IP地址<code>47.102.221.141</code>。</p><p>但对于<strong>cdn域名</strong>，一波查询下来，先得到的却是一条CNAME的记录<code>xx.kunlunaq.com</code>，然后dig这个<code>xx.kunlunaq.com</code>才能得到对应的<code>IP地址</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">dig</span> +trace cdn.xiaobaidebug.top
cdn.xiaobaidebug.top. <span class="token number">600</span> IN CNAME cdn.xiaobaidebug.top.w.kunlunaq.com.

$ <span class="token function">dig</span> +trace cdn.xiaobaidebug.top.w.kunlunaq.com
cdn.xiaobaidebug.top.w.kunlunaq.com. <span class="token number">300</span> IN A <span class="token number">122.228</span>.7.243
cdn.xiaobaidebug.top.w.kunlunaq.com. <span class="token number">300</span> IN A <span class="token number">122.228</span>.7.241
cdn.xiaobaidebug.top.w.kunlunaq.com. <span class="token number">300</span> IN A <span class="token number">122.228</span>.7.244
cdn.xiaobaidebug.top.w.kunlunaq.com. <span class="token number">300</span> IN A <span class="token number">122.228</span>.7.249
cdn.xiaobaidebug.top.w.kunlunaq.com. <span class="token number">300</span> IN A <span class="token number">122.228</span>.7.248
cdn.xiaobaidebug.top.w.kunlunaq.com. <span class="token number">300</span> IN A <span class="token number">122.228</span>.7.242
cdn.xiaobaidebug.top.w.kunlunaq.com. <span class="token number">300</span> IN A <span class="token number">122.228</span>.7.250
cdn.xiaobaidebug.top.w.kunlunaq.com. <span class="token number">300</span> IN A <span class="token number">122.228</span>.7.251
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看到这里，问题就又来了。</p><blockquote><p>为什么要加个CNAME那么麻烦？</p></blockquote><p>CNAME里指向的，其实是<strong>CDN专用的DNS域名服务器</strong>，它对整个DNS体系来说，只是其中一台小小的DNS域名服务器，<strong>看起来就跟其他域名服务器一样，平平无奇</strong>。DNS请求也会正常打入这个服务器里。</p><p>但当请求真正打到它上面的时候，它的特别之处就体现出来了，当查询请求打入域名服务器时，<strong>普通的DNS域名服务器</strong>返回域名对应的部分IP就够了，但CDN专用的<strong>DNS域名服务器</strong>却会要求返回离调用方&quot;<strong>最近的</strong>&quot;服务器IP。</p><p><img src="`+u+`" alt="CDN专用的DNS解析服务器会返回就近的CDN节点IP"></p><blockquote><p>怎么知道哪个服务器IP里调用方最近？</p></blockquote><p>可以看到&quot;最近&quot;这个词其实是加了<strong>双引号</strong>的。</p><p><strong>CDN专用的DNS域名服务器</strong>其实是CDN提供商提供的，比如阿里云当然知道自己的的<strong>CDN节点</strong>有哪些，以及这些CDN服务器目前的负载情况和响应延时甚至权重啥的，并且也能知道调用方的IP地址是什么，可以通过调用方的IP知道它所属的运营商以及大概所在地，根据条件筛选出<strong>最合适</strong>的CDN服务器，这就是所谓的&quot;<strong>最近</strong>&quot;。</p><p>举个例子。假设地理位置最近的CDN机房流量较多，响应较慢，但地理位置远一些的服务器却能更好的响应当前请求，那按理说<strong>可能</strong>会选择地理位置<strong>远一些</strong>的那台CDN服务器。</p><p>也就是说，选出来的服务器<strong>不一定在地理位置最近</strong>，但一定是当前<strong>最合适</strong>的服务器。</p><h2 id="回源是什么" tabindex="-1"><a class="header-anchor" href="#回源是什么" aria-hidden="true">#</a> 回源是什么</h2><p>上面的图片URL，是<code>https://cdn域名/图片地址.png</code>的形式。</p><p>也就是说这张图片是访问CDN拿到的。</p><p>那么，<strong>直接访问对象存储能不能拿到图片数据并展示？</strong></p><p>比如像下面这样。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>https://oss域名/图片地址.png
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这就像问，不走redis，直接从mysql中能不能读取到文本数据并展示一样。</p><p><strong>当然能。</strong></p><p>我之前放在博客里的图片就是这么干的。</p><p>但这样成本更高，这里的<strong>成本</strong>，可以指<strong>性能成本</strong>，也可以指<strong>调用成本</strong>。看下下面这个图。</p><p><img src="`+m+'" alt="1667101182393"></p><p>可以看到直接请求oss的费用差不多是通过cdn请求oss的两倍，考虑到家境贫寒，同时也为了让博客获取图片的速度更快，我就接入了CDN。</p><p>但看到这里，问题又又来了。</p><p>上面的截图里，红框里有个词叫&quot;<strong>回源</strong>&quot;。</p><p><strong>回源是什么？</strong></p><p>当我们访问<code>https://cdn域名/图片地址.png</code>时，请求会打到cdn服务器上面。</p><p>但cdn服务器本质上就是一层缓存，并不是数据源，<strong>对象存储才是数据源</strong>。</p><p><strong>第一次</strong>访问cdn获取某张图片时，大概率在cdn里并没有这张图片的数据，因此需要<strong>回</strong>到数据<strong>源</strong>那去取出这份图片数据。然后再放到cdn上。下次再次访问cdn时，只要缓存不过期，就能命中缓存直接返回，这就不需要再回源。</p><p>于是访问的过程就变成了下面这样。</p><p><img src="'+b+'" alt="1668605964836"></p><p><strong>那还有哪些情况会发生回源呢？</strong></p><p>除了上面提到的cdn上拿不到数据会回源站外，还有cdn上的<strong>缓存过期失效了</strong>也会导致回源站。</p><p>另外，就算有缓存，且缓存不过期，也可以通过cdn提供的<strong>开放接口来触发主动回源</strong>，但这个我们比较少机会能接触到。</p><p>另外，回源这个事情，其实用户是<strong>感知不到</strong>的，因为用户去读图片的时候，只能知道自己读到了还是读不到。</p><p>同样是<strong>读到了</strong>，还细分为是<strong>从cdn那直接读的</strong>，还是<strong>cdn回源读对象存储之后返回的</strong>。</p><p><img src="'+N+'" alt="有缓存直接返回和没缓存回源的区别"></p><p>那么，<strong>我们有办法判断是否发生过回源吗？</strong></p><p>有。我们接着往下看。</p><h2 id="怎么判断是否发生回源" tabindex="-1"><a class="header-anchor" href="#怎么判断是否发生回源" aria-hidden="true">#</a> 怎么判断是否发生回源</h2><p>我们以某里云的对象存储和CDN为例。</p><p>假设我要请求下面这张图<code>https://cdn.xiaobaidebug.top/image/image-20220404094549469.png</code></p><p>为了更方便的查看响应数据的<code>http header</code>，我们可以用上<code>postman</code>。</p><p>通过GET方法去请求图片数据。</p><p>然后通过下面的<code>tab</code>切换查看<code>response header</code>信息。</p><p><img src="'+h+'" alt="查看response-header"></p><p><img src="'+D+'" alt="回源的情况"></p><p>此时查看<code>response header</code>下的<code>X-Cache</code>的值是 <code>MISS TCP_MISS</code>。意思是未命中缓存导致CDN回源查oss，拿到数据后再返回。</p><p>那此时CDN里肯定是有这张图片的缓存了。我们可以试着<strong>再执行</strong>一次 GET 方法获取图片。</p><p><img src="'+C+'" alt="1667095186020"><code>X-Cache</code>的值就变成了 <code>HIT TCP_MEM_HIT</code>，这就是命中缓存了。</p><p>这个是某里云的做法，其他比如腾某云啥的，也都大差不差，几乎都可以从<code>response header</code>里找到相关的信息。</p><h2 id="用了cdn一定比不用的更快吗" tabindex="-1"><a class="header-anchor" href="#用了cdn一定比不用的更快吗" aria-hidden="true">#</a> 用了CDN一定比不用的更快吗？</h2><p>看到这里我们就可以回答文章开头的问题了。</p><p>如果没有接入CDN，直接访问源站，流程是这样的。</p><p><img src="'+v+'" alt="更新直接访问源站"> 但如果接入了CDN，且CDN上没有缓存数据，那就会触发回源。</p><p><img src="'+_+'" alt="更新走了CDN还回源"> 相当于在原来的流程上还多了一层CDN的调用流程。</p><p>也就是，用了CDN时，<strong>未命中CDN缓存</strong>导致<strong>回源</strong>，就会比不用的时候更慢。</p><p>未命中缓存，可能是<strong>cdn里压根就没这一数据</strong>，也可能是<strong>曾经有这条数据但后来过期失效了</strong>。</p><p>这两种情况都正常，<strong>大部分时候并不需要做任何处理</strong>。</p><p>但对于极个别场景，我们可能需要做些优化。比如你们源站数据有大版本更新，就像<strong>更换cdn域名</strong>啥的，那在上线的那一刻用户全用新cdn域名去请求图片啥的，新CDN节点基本上百分百触发回源，严重的时候甚至可能会拖垮对象存储。这时候你可能需要提前将热点数据筛选出来，利用工具预先请求一波，让CDN加载上热数据缓存。比如某里云上的CDN就有这样的&quot;<strong>刷新预热</strong>&quot;功能。</p><p><img src="'+k+'" alt="cdn刷新预热"> 当然也可以通过<strong>灰度发布</strong>的模式，先让少量用户体验新功能，让这些用户把cdn&quot;热&quot;起来，然后再逐步放开流量。</p><p>还有就是<strong>曾经有这条数据但后来过期失效了</strong>，对于热点数据，可以适当提高一下cdn数据的<strong>缓存时间</strong>。</p><p><img src="'+q+'" alt="1667344813600"></p><h2 id="什么情况下不应该使用cdn" tabindex="-1"><a class="header-anchor" href="#什么情况下不应该使用cdn" aria-hidden="true">#</a> 什么情况下不应该使用CDN？</h2><p>从上面的描述看下来，CDN最大的优势在于，对于来自世界各地的用户，它可以<strong>就近分配CDN节点</strong>获取数据，并且<strong>多次重复获取同一个文件</strong>数据的时候，有缓存加速的作用。</p><p>这对于网页图片这样的场景，是再合适不过了。因为底层用的是<strong>对象存储</strong>，也就是说，只要是文件对象，比如<strong>视频</strong>啥的，都可以用这套流程接入cdn做加速。比如平时刷的某音某手短视频就是这么干的。</p><p>那反过来想想，问题就来了。</p><p><strong>什么情况下不应该使用CDN？</strong></p><p>如果你有一个公司<strong>内网</strong>的服务，并且服务请求的图片等文件不太可能被<strong>多次重复调用</strong>，这时候其实没必要使用CDN。</p><p>注意上面两个<strong>加粗</strong>了的关键点。</p><p>• <strong>内网服务</strong>，是为了保证你是了解服务的请求来源的，也能拿到对象存储的<strong>读权限</strong>，并且如果你的对象存储也是公司内部的，那大概率跟你的服务已经在<strong>同一个机房</strong>里，这已经<strong>很近了</strong>。接入CDN也享受不到&quot;就近分配CDN节点&quot;所带来的好处。</p><p>• 图片或其他文件<strong>不太可能被多次重复使用</strong>，如果接入了CDN，那你每次去访问CDN获取图片的时候，CDN节点上大概率没有你要的数据，相当于每次都需要<strong>回源</strong>到对象存储去取一把。那接入CDN相当于给自己加了一层代理，多一层代理，就多一层耗时。</p><p><img src="'+x+'" alt="1668612494972"></p><p>关于上面的第二点，如果你需要一个明确的指标去说服自己，那我可以给你一个。从上面的介绍内容，我们知道，可以通过cdn响应的http header中的<code>X-Cache</code>字段，看到一个请求是否触发过回源，统计次数，再除以总的请求数，就能得到回源的比例，比如回源比例高达90%，那还接啥cdn。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2>',119),f=s("div",{class:"custom-container info"},[s("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[s("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[s("circle",{cx:"12",cy:"12",r:"9"}),s("path",{d:"M12 8h.01"}),s("path",{d:"M11 12h1v4h1"})])]),s("p",{class:"custom-container-title"},"INFO"),s("p",null,"• 对于文本类数据我们习惯用mysql做存储，redis做缓存。但属于文件类数据，比如视频图片，则需要使用oss等做对象存储，cdn做缓存。"),s("p",null,"• 用了CDN如果发生回源，那实际上会比不用的时候更慢一些。"),s("p",null,[n("• CDN最大的优势在于，对于来自世界各地的用户，它可以"),s("strong",null,"就近分配CDN"),n("节点获取数据，并且"),s("strong",null,"多次重复获取同一个文件"),n("数据的时候，有缓存加速的作用。如果你的服务和对象存储都在内网，并且文件数据也不太会有重复使用的可能性，那其实没必要接入cdn。")])],-1),w=[I,f];function A(P,y){return t(),e("div",null,w)}const M=o(S,[["render",A],["__file","index.html.vue"]]);export{M as default};
